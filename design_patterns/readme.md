# 设计模式

## 一. 如何定义代码质量
* 可维护性（maintainability）
* 可读性（readability）
* 可扩展性（extensibility）
* 灵活性（flexibility)
* 简洁性（simplicity）
* 可复用性（reusability）
* 可测试性（testability)

面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；
设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出
可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；
持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护
性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

## 二. 编程方法论

* 面向对象
* 设计原则
* 设计模式
* 编程规范
* 重构技巧

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。


### 2.1 面向对象
面向对象的四大特性：封装、抽象、继承、多态

### 2.2 设计原则
* SOLID 原则 -SRP 单一职责原则
* SOLID 原则 -OCP 开闭原则
* SOLID 原则 -LSP 里式替换原则
* SOLID 原则 -ISP 接口隔离原则
* SOLID 原则 -DIP 依赖倒置原则
* DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


### 2.3 设计模式
有 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。


| 创建型  | 结构型 | 行为型| 
| ------------- |:-------------:| ------------- |
| 单例模式      | 代理模式    | 观察者模式      |
| 工厂模式      | 桥接模式     | 模板模式      |
| 建造者模式 | 装饰者模式     | 策略模式      |
| 原型模式(不常用) | 适配器模式 | 职责链模式      |
| x | 组合模式(不常用) | 迭代器模式      |
| x | 享元模式(不常用)| 状态模式      |
| x | 门面模式(不常用) | 访问者模式(不常用)      |
| x | x    | 备忘录模式(不常用)      |
| x | x    | 命令模式(不常用)      |
| x | x    | 解释器模式(不常用)      |
| x | x    | 中介模式(不常用)      |

### 2.4 编程规范
[google code styleguide](https://google.github.io/styleguide/cppguide.html)


### 2.5 重构技巧
1. 重构的目的（why）、对象（what）、时机（when）、方法（how）；
2. 保证重构不出错的技术手段：单元测试和代码的可测试性；
3. 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

## 三. 面向对象的编程与设计模式
### 封装
封装也叫作信息隐藏或者数据访问保护。它是通过 private、protected、public等关键字来实现的。
封装特性存在的意义，一方面是保护数据 不被随意修改，提高代码的可维护性;另一方面是仅暴露有限的必要接口，提高类的易用性。
### 抽象
抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围; 另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
### 继承
继承是用来表示类之间的 is-a 关系。
继承主要是用来解决代码复用的问题。
### 多态
1. 如何支持多态?

> 语法机制是编程语言要支持父类对象可以引用子类对象.  
> 语法机制是编程语言要支持继承.  
> 语法机制是编程语言要支持子类可以重写(override)父类中的方法.  

2. 多态特性存在的意义？  
>  多态特性能提高代码的可扩展性和复用性。  
>  多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、 基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等

3. **如何避免多重继承的副作用的？**  
> ?  

## 四. 面向对象与面向过程
> 面向过程：完成一个任务，你需要先做什么后做什么，这是流程化思维过程。  
> 面向对象：完成一个任务，首先拆解为一个一个小模块，然后考虑模块之间交互。  

1. 违反面向对象的设计  
> 滥用 getter、setter 方法  
> 滥用全局变量和全局方. (Constants 类、Utils 类的设计问题)
> 定义数据和方法分离的类. (基于贫血模型的开发模式)


## 五. 接口vs抽象类的区别
### 区别
1. 抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来.
2. 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法
3. 接口不能包含属性(也就是成员变量)
4. 接口只能声明方法，方法不能包含代码实现。
5. 类实现接口的时候，必须实现接口中声明的所有方法。
6. 相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议(contract)。

### 抽象是解决什么问题？
抽象类不能实例化，只能被继承。继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义 的属性和方法，避免在子类中，重复编写相同的代码。  它约束了必须重写抽象方法。

### 接口是解决什么问题？
抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于 一组协议或者契约，类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降 低代码间的耦合性，提高代码的可扩展性。


## 六. 基于接口而非实现编程
即： 基于抽象而非实现编程。  

1. 在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼; 另一方面，与特定实现有关的方法不要定义在接口中。
2. “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更 加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接 口”设计。

**遵从'基于接口而非实现编程'的原则**
1. 函数的命名不能暴露任何实现细节。
2. 封装具体的实现细节。
3. 为实现类定义抽象的接口。

**什么时候，该为某个类定义接口?**
> 基于接口而非实现编程的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生 变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。
> 如果在我们的业务场景中，某个功能只有一种实现方式，未来也不 可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直 接使用实现类就可以了。

## 七. 组合 vs 继承
设计原则，那就是:组合优于继承，多用组合少用继承。

## 为什么不推荐使用继承?
继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问 题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种 情况下，我们应该尽量少用，甚至不用继承。  
## 组合相比继承有哪些优势?

继承主要有三个作用:表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通 过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂 的继承关系影响代码可维护性的问题。

### 如何判断该用组合还是继承?
1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的 例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更 多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在 实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。  
2. 如果类之间的继承结构稳定(不会轻易改变)，继承层次比较浅(比如，最多有两层继承关 系)，继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很 深，继承关系复杂，我们就尽量使用组合来替代继承。  


## 八. 如何对一个功能开发来做面向对象分析?

1. 需求分析  
  1.1 通过 “提出问题 - 解决问题” 的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。 
2. 面向对象设计  
  2.1  划分职责进而识别出有哪些类。  
  2.2  定义类及其属性和方法;  
  2.3  定义类与类之间的交互关系;  
  2.4  将类组装起来并提供执行入口。  
3. 面向对象编程

**如何划分职责进而识别出有哪些类？**
 > 根据需求描述，把其中涉及的功能点，一个一个 罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。 针对这种复 杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功 能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和 识别，跟类的划分和识别，是类似的套路。   
 
 **如何划定义类及其属性和方法？**
 > 识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。
 > 在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的 需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证 类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。
 **如何定义类与类之间的交互关系？**
 > 泛化(Generalization)可以简单理解为继承关系。
 > 实现(Realization)一般是指接口和实现类之间的关系。
 > 聚合(Aggregation)是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可 以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，
 > 组合(Composition)也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期 跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。
 > 关联(Association)是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面， 如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。
 > 依赖(Dependency)是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象 是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量， 只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。
 
 
## 九.  单一职责原则

**如何理解单一职责原则(SRP)?**
> 一个类只负责完成一个职责或者功能。也 就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类 包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成 多个功能更加单一、粒度更细的类。
> 综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标 准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中， 我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类，满足业务需 求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以 将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。
> 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑 对类进行拆分;
> 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想， 我们就需要考虑对类进行拆分;
> 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供 更多的类使用，从而提高代码的复用性;
> 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰;
> 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半 的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。
**类的职责是否设计得越单一越好?**
> 单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚 性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此 来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内 聚性，也会影响代码的可维护性。

## 十.  如何理解“对扩展开放、修改关闭”?

**如何理解“对扩展开放、修改关闭”?**
> 添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性 等)，而非修改已有代码(修改模块、类、方法、属性等)的方式来完成。关于定义，我们 有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价 来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修 改”;在细代码粒度下，可能又被认定为“扩展”。  

**如何做到“对扩展开放、修改关闭”?**
> 我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考 一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未 来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活 地插入到扩展点上。
> 很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为 指导原则的。最常用来提高代码扩展性的方法有:多态、依赖注入、基于接口而非实现编 程，以及大部分的设计模式(比如，装饰、策略、模板、职责链、状态)。

## 十.  如何理解里式替换原则?
里式替换原则： 子类在设计的时候，要遵守父类的行为约定(或者 叫协议)。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变 函数原有的行为约定。这里的行为约定包括:函数声明要实现的功能;对输入、输出、异常 的约定;甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系， 也可以替换成接口和实现类之间的关系。  
**里式替换原则与多态区别？**
> 虽然从定义描述和代码实现上来看，多态和里式替换有点类似， 但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的 一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破 坏原有程序的正确性。

**哪些代码明显违背了LSP?**
1. 子类违背父类声明要实现的功能
2. 子类违背父类对输入、输出、异常的约定
3. 子类违背父类注释中所罗列的任何特殊说明

## 十一.  如何理解 接口隔离原则？
理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我 们可以把“接口”理解为下面三种东西：  
1. 一组 API 接口集合  
2. 单个 API 接口或函数  
3. OOP 中的接口概念  
> 如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口 等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
> 如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我 们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
> 如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那 接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

**接口隔离原则与单一职责原则的区别**
> 单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面 更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接 口的职责是否单一的标准:通过调用者如何使用接口来间接地判定。如果调用者只使用部分 接口或接口的部分功能，那接口的设计就不够职责单一。


## 十二.  如何理解依赖反转原则？

### 控制反转
实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导 框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在 没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流 程通过框架来控制。流程的控制权从程序员“反转”给了框架。  

### 依赖注入
依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内 部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等 方式传递(或注入)给类来使用。

### 依赖注入框架  
我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关 系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员 来做的事情。  

### 依赖反转原则  
> 依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面 的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细 节，具体实现细节依赖抽象。  
> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.  
> 将它翻译成中文，大概意思就是:高层模块(high-level modules)不要依赖低层模 块(low-level)。高层模块和低层模块应该通过抽象(abstractions)来互相依赖。除此 之外，抽象(abstractions)不要依赖具体实现细节(details)，具体实现细节 (details)依赖抽象(abstractions)。  
> 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者 属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上， 这条原则主要还是用来指导框架层面的设计.  
> 我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高 层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没 有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依 赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

## 十三.  如何理解KISS、YAGNI原则？
KISS 原则：尽量保持简单。它是保持代码可读和可维护的重要手段。

**如何写出满足 KISS 原则的代码？**
1. 不要使用同事可能不懂的技术来实现代码;
2. 不要重复造轮子，要善于使用已经有的工具类库;
3. 不要过度优化。

YAGNI 原则的英文全称是:You Ain’t Gonna Need It。直译就是:你不会需要它。这条 原则也算是万金油了。当用在软件开发中的时候，它的意思是:不要去设计当前用不到的功 能;不要去编写当前用不到的代码。实际上，这条原则的核心思想就是:不要做过度设计。
