# 设计模式

## 一. 如何定义代码质量
* 可维护性（maintainability）
* 可读性（readability）
* 可扩展性（extensibility）
* 灵活性（flexibility)
* 简洁性（simplicity）
* 可复用性（reusability）
* 可测试性（testability)

面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；
设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出
可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；
持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护
性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

## 二. 编程方法论

* 面向对象
* 设计原则
* 设计模式
* 编程规范
* 重构技巧

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。


### 2.1 面向对象
面向对象的四大特性：封装、抽象、继承、多态

### 2.2 设计原则
* SOLID 原则 -SRP 单一职责原则
* SOLID 原则 -OCP 开闭原则
* SOLID 原则 -LSP 里式替换原则
* SOLID 原则 -ISP 接口隔离原则
* SOLID 原则 -DIP 依赖倒置原则
* DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


### 2.3 设计模式
有 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。


| 创建型  | 结构型 | 行为型| 
| ------------- |:-------------:| ------------- |
| 单例模式      | 代理模式    | 观察者模式      |
| 工厂模式      | 桥接模式     | 模板模式      |
| 建造者模式 | 装饰者模式     | 策略模式      |
| 原型模式(不常用) | 适配器模式 | 职责链模式      |
| x | 组合模式(不常用) | 迭代器模式      |
| x | 享元模式(不常用)| 状态模式      |
| x | 门面模式(不常用) | 访问者模式(不常用)      |
| x | x    | 备忘录模式(不常用)      |
| x | x    | 命令模式(不常用)      |
| x | x    | 解释器模式(不常用)      |
| x | x    | 中介模式(不常用)      |

### 2.4 编程规范
[google code styleguide](https://google.github.io/styleguide/cppguide.html)


### 2.5 重构技巧
1. 重构的目的（why）、对象（what）、时机（when）、方法（how）；
2. 保证重构不出错的技术手段：单元测试和代码的可测试性；
3. 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

## 三. 面向对象的编程与设计模式
### 封装
封装也叫作信息隐藏或者数据访问保护。它是通过 private、protected、public等关键字来实现的。
封装特性存在的意义，一方面是保护数据 不被随意修改，提高代码的可维护性;另一方面是仅暴露有限的必要接口，提高类的易用性。
### 抽象
抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围; 另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
### 继承
继承是用来表示类之间的 is-a 关系。
继承主要是用来解决代码复用的问题。
### 多态
1. 如何支持多态?

> 语法机制是编程语言要支持父类对象可以引用子类对象.  
> 语法机制是编程语言要支持继承.  
> 语法机制是编程语言要支持子类可以重写(override)父类中的方法.  

2. 多态特性存在的意义？  
>  多态特性能提高代码的可扩展性和复用性。  
>  多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、 基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等

3. **如何避免多重继承的副作用的？**  
> ?  

## 四. 面向对象与面向过程
> 面向过程：完成一个任务，你需要先做什么后做什么，这是流程化思维过程。  
> 面向对象：完成一个任务，首先拆解为一个一个小模块，然后考虑模块之间交互。  

1. 违反面向对象的设计  
> 滥用 getter、setter 方法  
> 滥用全局变量和全局方. (Constants 类、Utils 类的设计问题)
> 定义数据和方法分离的类. (基于贫血模型的开发模式)


## 五. 接口vs抽象类的区别
### 区别
1. 抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来.
2. 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法
3. 接口不能包含属性(也就是成员变量)
4. 接口只能声明方法，方法不能包含代码实现。
5. 类实现接口的时候，必须实现接口中声明的所有方法。
6. 相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议(contract)。

### 抽象是解决什么问题？
抽象类不能实例化，只能被继承。继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义 的属性和方法，避免在子类中，重复编写相同的代码。  它约束了必须重写抽象方法。

### 接口是解决什么问题？
抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于 一组协议或者契约，类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降 低代码间的耦合性，提高代码的可扩展性。


## 六. 基于接口而非实现编程
即： 基于抽象而非实现编程。  

1. 在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼; 另一方面，与特定实现有关的方法不要定义在接口中。
2. “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更 加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接 口”设计。

**遵从'基于接口而非实现编程'的原则**
1. 函数的命名不能暴露任何实现细节。
2. 封装具体的实现细节。
3. 为实现类定义抽象的接口。

**什么时候，该为某个类定义接口?**
> 基于接口而非实现编程的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生 变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。
> 如果在我们的业务场景中，某个功能只有一种实现方式，未来也不 可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直 接使用实现类就可以了。

## 七. 组合 vs 继承
设计原则，那就是:组合优于继承，多用组合少用继承。

## 为什么不推荐使用继承?
继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问 题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种 情况下，我们应该尽量少用，甚至不用继承。  
## 组合相比继承有哪些优势?

继承主要有三个作用:表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通 过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂 的继承关系影响代码可维护性的问题。

### 如何判断该用组合还是继承?
1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的 例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更 多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在 实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。  
2. 如果类之间的继承结构稳定(不会轻易改变)，继承层次比较浅(比如，最多有两层继承关 系)，继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很 深，继承关系复杂，我们就尽量使用组合来替代继承。  


## 八. 如何对一个功能开发来做面向对象分析?

1. 需求分析  
  1.1 通过 “提出问题 - 解决问题” 的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。 
2. 面向对象设计  
  2.1  划分职责进而识别出有哪些类。  
  2.2  定义类及其属性和方法;  
  2.3  定义类与类之间的交互关系;  
  2.4  将类组装起来并提供执行入口。  
3. 面向对象编程

**如何划分职责进而识别出有哪些类？**
 > 根据需求描述，把其中涉及的功能点，一个一个 罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。 针对这种复 杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功 能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和 识别，跟类的划分和识别，是类似的套路。   
 
 **如何划定义类及其属性和方法？**
 > 识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。
 > 在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的 需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证 类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。
 **如何定义类与类之间的交互关系？**
 > 泛化(Generalization)可以简单理解为继承关系。
 > 实现(Realization)一般是指接口和实现类之间的关系。
 > 聚合(Aggregation)是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可 以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，
 > 组合(Composition)也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期 跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。
 > 关联(Association)是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面， 如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。
 > 依赖(Dependency)是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象 是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量， 只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。
 
 
## 九.  单一职责原则

**如何理解单一职责原则(SRP)?**
> 一个类只负责完成一个职责或者功能。也 就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类 包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成 多个功能更加单一、粒度更细的类。
> 综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标 准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中， 我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类，满足业务需 求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以 将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。
> 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑 对类进行拆分;
> 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想， 我们就需要考虑对类进行拆分;
> 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供 更多的类使用，从而提高代码的复用性;
> 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰;
> 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半 的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。
**类的职责是否设计得越单一越好?**
> 单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚 性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此 来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内 聚性，也会影响代码的可维护性。

## 十.  如何理解“对扩展开放、修改关闭”?

**如何理解“对扩展开放、修改关闭”?**
> 添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性 等)，而非修改已有代码(修改模块、类、方法、属性等)的方式来完成。关于定义，我们 有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价 来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修 改”;在细代码粒度下，可能又被认定为“扩展”。  

**如何做到“对扩展开放、修改关闭”?**
> 我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考 一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未 来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活 地插入到扩展点上。
> 很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为 指导原则的。最常用来提高代码扩展性的方法有:多态、依赖注入、基于接口而非实现编 程，以及大部分的设计模式(比如，装饰、策略、模板、职责链、状态)。

## 十.  如何理解里式替换原则?
里式替换原则： 子类在设计的时候，要遵守父类的行为约定(或者 叫协议)。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变 函数原有的行为约定。这里的行为约定包括:函数声明要实现的功能;对输入、输出、异常 的约定;甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系， 也可以替换成接口和实现类之间的关系。  
**里式替换原则与多态区别？**
> 虽然从定义描述和代码实现上来看，多态和里式替换有点类似， 但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的 一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破 坏原有程序的正确性。

**哪些代码明显违背了LSP?**
1. 子类违背父类声明要实现的功能
2. 子类违背父类对输入、输出、异常的约定
3. 子类违背父类注释中所罗列的任何特殊说明

## 十一.  如何理解 接口隔离原则？
理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我 们可以把“接口”理解为下面三种东西：  
1. 一组 API 接口集合  
2. 单个 API 接口或函数  
3. OOP 中的接口概念  
> 如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口 等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
> 如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我 们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
> 如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那 接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

**接口隔离原则与单一职责原则的区别**
> 单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面 更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接 口的职责是否单一的标准:通过调用者如何使用接口来间接地判定。如果调用者只使用部分 接口或接口的部分功能，那接口的设计就不够职责单一。


## 十二.  如何理解依赖反转原则？

### 控制反转
实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导 框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在 没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流 程通过框架来控制。流程的控制权从程序员“反转”给了框架。  

### 依赖注入
依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内 部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等 方式传递(或注入)给类来使用。

### 依赖注入框架  
我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关 系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员 来做的事情。  

### 依赖反转原则  
> 依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面 的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细 节，具体实现细节依赖抽象。  
> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.  
> 将它翻译成中文，大概意思就是:高层模块(high-level modules)不要依赖低层模 块(low-level)。高层模块和低层模块应该通过抽象(abstractions)来互相依赖。除此 之外，抽象(abstractions)不要依赖具体实现细节(details)，具体实现细节 (details)依赖抽象(abstractions)。  
> 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者 属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上， 这条原则主要还是用来指导框架层面的设计.  
> 我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高 层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没 有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范。Servlet 规范不依 赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

## 十三.  如何理解KISS、YAGNI原则？
KISS 原则：尽量保持简单。它是保持代码可读和可维护的重要手段。

**如何写出满足 KISS 原则的代码？**
1. 不要使用同事可能不懂的技术来实现代码;
2. 不要重复造轮子，要善于使用已经有的工具类库;
3. 不要过度优化。

YAGNI 原则的英文全称是:You Ain’t Gonna Need It。直译就是:你不会需要它。这条 原则也算是万金油了。当用在软件开发中的时候，它的意思是:不要去设计当前用不到的功 能;不要去编写当前用不到的代码。实际上，这条原则的核心思想就是:不要做过度设计。


## 十四. 如何理解DRY 原则？
DRY原则：它的英文描述为:Don’t Repeat Yourself。中文直译为:不要重复自己。将它应用在编程中，可以理解为:不要写重复的代码。  
三种典型的代码重复情况，它们分别是:实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反;有的看似不违反，实际上却违反了。
1. 实现逻辑重复： 并没有违反
2. 功能语义重复： 违反了
3. 代码执行重复： 违反了

**提高代码可复用性的一些方法**
1. 减少代码耦合。对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为 一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵 连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少 代码耦合。
2. 满足单一职责原则。我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的 代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相 反，越细粒度的代码，代码的通用性会越好，越容易被复用。
3. 模块化。这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将 功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接 拿来搭建更加复杂的系统。
4. 业务与非业务逻辑分离。越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用 跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组 件等。
5. 通用代码下沉。从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复 用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层 代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码 我们尽量下沉到更下层。
6. 继承、多态、抽象、封装。在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用 父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复 用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的 话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露 不变的接口，就越容易复用。
7. 应用模板等设计模式。一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替 换其中的部分代码，整个流程模板代码可复用。

## 十四. 如何理解迪米特法则(LOD)？
“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性， 缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指 导类与类之间依赖关系的设计。  

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会 或者很少导致依赖类的代码改动。  

不该有直接依赖关系的类之间，不要有依赖;有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其 他部分。一旦发生变化，需要了解这一变化的类就会比较少。


## 十五. 如何针对业务系统的开发，如何做需求分析和设计？

### 需求分析
1. 首先，一定不要自己一个人闷头 想。一方面，这样做很难想全面。另一方面，从零开始设计也比较浪费时间。所以，我们要 学会“借鉴”。爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”。你看大师 都含蓄地表达了“借鉴”的重要性，我们也没有必要因为“借鉴”而感到不好意思了。
2. 通 过产品的线框图、用户用例(user case )或者叫用户故事(user story)来细化业务流 程，挖掘一些比较细节的、不容易想到的功能点。用户用例有点儿 类似我们后面要讲的单元测试用例。它侧重情景化，其实就是模拟用户如何使用我们的产 品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。

### 系统设计
1. 合理地将功能划分到不同模块。 面向对象设计的本质就是把合适的代码放到合适 的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代 码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际 上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低 耦合，架构整洁清晰。
2. 设计模块与模块之间的交互关系。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟该系统之间有交互以及如何进行交互。上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。
3. 设计模块的接口、数据库、业务模型。实际上，业务系统本身的设计无外乎有这样三方面的工作要做:接口设计、数据库设计 和业务模型设计。


**怎么判断哪种模块划分合理呢?**
1. 实际上，我们可以反过来通过看它是否符合高内聚、低耦合 特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说 明模块划分的不够合理，职责不够清晰，耦合过于严重。
2. 除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系 统(也就是被调用的系统)包含太多上层系统(也就是调用系统)的业务信息，但是，可以 接受上层系统包含下层系统的业务信息。

## 十六. 如何针对非业务的通用框架开发，如何做需求分析和设计？

1. 需求分析  
对于非业务通用框架的开发，我们在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如，框架的易用性、性能、扩展性、容错性、通用性等。  
2. 框架设计。 应对复杂系统的设计实现，我今天讲到了聚焦简单场景、最小原型、画图等几个技巧。  
  2.1 对于稍微复杂系统的开发，很多人觉得不知从何开始。我个人喜欢借鉴 TDD(测试驱动开 发)和 Prototype(最小原型)的思想，先聚焦于一个简单的应用场景，基于此设计实现 一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得 见、摸得着，比较具体、不抽象，能够很有效地帮助我缕清更复杂的设计思路，是迭代设计 的基础。    
  2.2 将框架根据需求分析 分模块。
3. 面向对象设计与实现  
  3.1  划分职责进而识别出有哪些类  
  3.2  定义类及类与类之间的关系。 面向对象设计和实现要做的事情，就是把合适的代码 放到合适的类中。  
  3.3  将类组装起来并提供执行入口  
4. Review 设计与实现。  是否符合SOLID、KISS、DRY、YAGNI、LOD 等设计原则，基于接口而非实现编程、多用组合少用继承、高内聚低耦合等设计思想。  

写代码的过程本就是一个修修改改、不停调整的过程，肯定不是一气呵成的。你看到的那些 大牛开源项目的设计和实现，也都是在不停优化、修改过程中产生的。比如，我们熟悉的 Unix 系统，第一版很简单、粗糙，代码不到 1 万行。所以，迭代思维很重要，不要刚开始 就追求完美。  


## 十七. 什么是重构？
1. 重构的目的:为什么重构(why)?
> 对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地 步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它 是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。    
2. 重构的对象:重构什么(what)?  
> 按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大 规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等 等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层 次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细 节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一 理论知识。

3. 重构的时机:什么时候重构(when)?  
> 一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常 开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。  

4. 重构的方法:如何重构(how)?
>  大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代 码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以， 只要你愿意并且有时间，随时随地都可以去做。


