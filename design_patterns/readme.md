# 设计模式

## 一. 如何定义代码质量
* 可维护性（maintainability）
* 可读性（readability）
* 可扩展性（extensibility）
* 灵活性（flexibility)
* 简洁性（simplicity）
* 可复用性（reusability）
* 可测试性（testability)

面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；
设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出
可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；
持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护
性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

## 二. 编程方法论

* 面向对象
* 设计原则
* 设计模式
* 编程规范
* 重构技巧

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。


### 2.1 面向对象
面向对象的四大特性：封装、抽象、继承、多态

### 2.2 设计原则
* SOLID 原则 -SRP 单一职责原则
* SOLID 原则 -OCP 开闭原则
* SOLID 原则 -LSP 里式替换原则
* SOLID 原则 -ISP 接口隔离原则
* SOLID 原则 -DIP 依赖倒置原则
* DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


### 2.3 设计模式
有 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。


| 创建型  | 结构型 | 行为型| 
| ------------- |:-------------:| ------------- |
| 单例模式      | 代理模式    | 观察者模式      |
| 工厂模式      | 桥接模式     | 模板模式      |
| 建造者模式 | 装饰者模式     | 策略模式      |
| 原型模式(不常用) | 适配器模式 | 职责链模式      |
| x | 组合模式(不常用) | 迭代器模式      |
| x | 享元模式(不常用)| 状态模式      |
| x | 门面模式(不常用) | 访问者模式(不常用)      |
| x | x    | 备忘录模式(不常用)      |
| x | x    | 命令模式(不常用)      |
| x | x    | 解释器模式(不常用)      |
| x | x    | 中介模式(不常用)      |

### 2.4 编程规范
[google code styleguide](https://google.github.io/styleguide/cppguide.html)


### 2.5 重构技巧
1. 重构的目的（why）、对象（what）、时机（when）、方法（how）；
2. 保证重构不出错的技术手段：单元测试和代码的可测试性；
3. 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

## 三. 面向对象的编程与设计模式
### 封装
封装也叫作信息隐藏或者数据访问保护。它是通过 private、protected、public等关键字来实现的。
封装特性存在的意义，一方面是保护数据 不被随意修改，提高代码的可维护性;另一方面是仅暴露有限的必要接口，提高类的易用性。
### 抽象
抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围; 另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
### 继承
继承是用来表示类之间的 is-a 关系。
继承主要是用来解决代码复用的问题。
### 多态
1. 如何支持多态?

> 语法机制是编程语言要支持父类对象可以引用子类对象.  
> 语法机制是编程语言要支持继承.  
> 语法机制是编程语言要支持子类可以重写(override)父类中的方法.  

2. 多态特性存在的意义？  
>  多态特性能提高代码的可扩展性和复用性。  
>  多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、 基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等

3. **如何避免多重继承的副作用的？**  
> ?  

## 四. 面向对象与面向过程
> 面向过程：完成一个任务，你需要先做什么后做什么，这是流程化思维过程。  
> 面向对象：完成一个任务，首先拆解为一个一个小模块，然后考虑模块之间交互。  

1. 违反面向对象的设计  
> 滥用 getter、setter 方法  
> 滥用全局变量和全局方. (Constants 类、Utils 类的设计问题)
> 定义数据和方法分离的类. (基于贫血模型的开发模式)


## 五. 接口vs抽象类的区别
### 区别
1. 抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来.
2. 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法
3. 接口不能包含属性(也就是成员变量)
4. 接口只能声明方法，方法不能包含代码实现。
5. 类实现接口的时候，必须实现接口中声明的所有方法。
6. 相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议(contract)。

### 抽象是解决什么问题？
抽象类不能实例化，只能被继承。继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义 的属性和方法，避免在子类中，重复编写相同的代码。  它约束了必须重写抽象方法。

### 接口是解决什么问题？
抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于 一组协议或者契约，类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降 低代码间的耦合性，提高代码的可扩展性。


## 六. 基于接口而非实现编程
即： 基于抽象而非实现编程。  

1. 在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼; 另一方面，与特定实现有关的方法不要定义在接口中。
2. “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更 加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接 口”设计。

**遵从'基于接口而非实现编程'的原则**
1. 函数的命名不能暴露任何实现细节。
2. 封装具体的实现细节。
3. 为实现类定义抽象的接口。

**什么时候，该为某个类定义接口?**
> 基于接口而非实现编程的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生 变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。
> 如果在我们的业务场景中，某个功能只有一种实现方式，未来也不 可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直 接使用实现类就可以了。

## 七. 组合 vs 继承
设计原则，那就是:组合优于继承，多用组合少用继承。

## 为什么不推荐使用继承?
继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问 题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种 情况下，我们应该尽量少用，甚至不用继承。  
## 组合相比继承有哪些优势?

继承主要有三个作用:表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通 过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂 的继承关系影响代码可维护性的问题。

### 如何判断该用组合还是继承?
1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的 例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更 多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在 实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。  
2. 如果类之间的继承结构稳定(不会轻易改变)，继承层次比较浅(比如，最多有两层继承关 系)，继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很 深，继承关系复杂，我们就尽量使用组合来替代继承。  


## 八. 如何对一个功能开发来做面向对象分析?

1. 需求分析  
  1.1 通过 “提出问题 - 解决问题” 的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。 
2. 面向对象设计  
  2.1  划分职责进而识别出有哪些类。  
  2.2  定义类及其属性和方法;  
  2.3  定义类与类之间的交互关系;  
  2.4  将类组装起来并提供执行入口。  
3. 面向对象编程

**如何划分职责进而识别出有哪些类？**
 > 根据需求描述，把其中涉及的功能点，一个一个 罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。 针对这种复 杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功 能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和 识别，跟类的划分和识别，是类似的套路。   
 
 **如何划定义类及其属性和方法？**
 > 识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。
 > 在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的 需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证 类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。
 **如何定义类与类之间的交互关系？**
 > 泛化(Generalization)可以简单理解为继承关系。
 > 实现(Realization)一般是指接口和实现类之间的关系。
 > 聚合(Aggregation)是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可 以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，
 > 组合(Composition)也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期 跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。
 > 关联(Association)是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面， 如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。
 > 依赖(Dependency)是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象 是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量， 只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。
 
 
## 九.  单一职责原则

**如何理解单一职责原则(SRP)?**
> 一个类只负责完成一个职责或者功能。也 就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类 包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成 多个功能更加单一、粒度更细的类。
> 综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标 准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中， 我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类，满足业务需 求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以 将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。
> 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑 对类进行拆分;
> 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想， 我们就需要考虑对类进行拆分;
> 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供 更多的类使用，从而提高代码的复用性;
> 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰;
> 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半 的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。
**类的职责是否设计得越单一越好?**
> 单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚 性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此 来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内 聚性，也会影响代码的可维护性。

## 十.  如何理解“对扩展开放、修改关闭”?

**如何理解“对扩展开放、修改关闭”?**
> 添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性 等)，而非修改已有代码(修改模块、类、方法、属性等)的方式来完成。关于定义，我们 有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价 来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修 改”;在细代码粒度下，可能又被认定为“扩展”。
**如何做到“对扩展开放、修改关闭”?**
> 我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考 一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未 来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活 地插入到扩展点上。
> 很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为 指导原则的。最常用来提高代码扩展性的方法有:多态、依赖注入、基于接口而非实现编 程，以及大部分的设计模式(比如，装饰、策略、模板、职责链、状态)。



