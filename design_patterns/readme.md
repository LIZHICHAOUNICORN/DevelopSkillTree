# 设计模式

## 一. 如何定义代码质量
* 可维护性（maintainability）
* 可读性（readability）
* 可扩展性（extensibility）
* 灵活性（flexibility)
* 简洁性（simplicity）
* 可复用性（reusability）
* 可测试性（testability)

面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；
设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出
可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；
持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护
性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

## 二. 编程方法论

* 面向对象
* 设计原则
* 设计模式
* 编程规范
* 重构技巧

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。


### 2.1 面向对象
面向对象的四大特性：封装、抽象、继承、多态

### 2.2 设计原则
* SOLID 原则 -SRP 单一职责原则
* SOLID 原则 -OCP 开闭原则
* SOLID 原则 -LSP 里式替换原则
* SOLID 原则 -ISP 接口隔离原则
* SOLID 原则 -DIP 依赖倒置原则
* DRY 原则、KISS 原则、YAGNI 原则、LOD 法则


### 2.3 设计模式
有 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。


| 创建型  | 结构型 | 行为型| 
| ------------- |:-------------:| ------------- |
| 单例模式      | 代理模式    | 观察者模式      |
| 工厂模式      | 桥接模式     | 模板模式      |
| 建造者模式 | 装饰者模式     | 策略模式      |
| 原型模式(不常用) | 适配器模式 | 职责链模式      |
| x | 组合模式(不常用) | 迭代器模式      |
| x | 享元模式(不常用)| 状态模式      |
| x | 门面模式(不常用) | 访问者模式(不常用)      |
| x | x    | 备忘录模式(不常用)      |
| x | x    | 命令模式(不常用)      |
| x | x    | 解释器模式(不常用)      |
| x | x    | 中介模式(不常用)      |

### 2.4 编程规范
[google code styleguide](https://google.github.io/styleguide/cppguide.html)


### 2.5 重构技巧
1. 重构的目的（why）、对象（what）、时机（when）、方法（how）；
2. 保证重构不出错的技术手段：单元测试和代码的可测试性；
3. 两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

## 三. 面向对象的编程与设计模式
### 封装
封装也叫作信息隐藏或者数据访问保护。它是通过 private、protected、public等关键字来实现的。
封装特性存在的意义，一方面是保护数据 不被随意修改，提高代码的可维护性;另一方面是仅暴露有限的必要接口，提高类的易用性。
### 抽象
抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围; 另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
### 继承
继承是用来表示类之间的 is-a 关系。
继承主要是用来解决代码复用的问题。
### 多态
1. 如何支持多态?

> 语法机制是编程语言要支持父类对象可以引用子类对象.  
> 语法机制是编程语言要支持继承.  
> 语法机制是编程语言要支持子类可以重写(override)父类中的方法.  

2. 多态特性存在的意义？  
>  多态特性能提高代码的可扩展性和复用性。  
>  多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、 基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等

3. **如何避免多重继承的副作用的？**  
> ?  

## 四. 面向对象与面向过程
> 面向过程：完成一个任务，你需要先做什么后做什么，这是流程化思维过程。  
> 面向对象：完成一个任务，首先拆解为一个一个小模块，然后考虑模块之间交互。  

1. 违反面向对象的设计  
> 滥用 getter、setter 方法  
> 滥用全局变量和全局方. (Constants 类、Utils 类的设计问题)
> 定义数据和方法分离的类. (基于贫血模型的开发模式)


## 五. 接口vs抽象类的区别
### 区别
1. 抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来.
2. 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法
3. 接口不能包含属性(也就是成员变量)
4. 接口只能声明方法，方法不能包含代码实现。
5. 类实现接口的时候，必须实现接口中声明的所有方法。
6. 相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议(contract)。

### 抽象是解决什么问题？
抽象类不能实例化，只能被继承。继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义 的属性和方法，避免在子类中，重复编写相同的代码。  它约束了必须重写抽象方法。

### 接口是解决什么问题？
抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于 一组协议或者契约，类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降 低代码间的耦合性，提高代码的可扩展性。


## 六. 基于接口而非实现编程
即： 基于抽象而非实现编程。  

1. 在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼; 另一方面，与特定实现有关的方法不要定义在接口中。
2. “基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更 加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接 口”设计。

**遵从'基于接口而非实现编程'的原则**
1. 函数的命名不能暴露任何实现细节。
2. 封装具体的实现细节。
3. 为实现类定义抽象的接口。

**什么时候，该为某个类定义接口?**
> 基于接口而非实现编程的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生 变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。
> 如果在我们的业务场景中，某个功能只有一种实现方式，未来也不 可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直 接使用实现类就可以了。

## 七. 组合 vs 继承
设计原则，那就是:组合优于继承，多用组合少用继承。

## 为什么不推荐使用继承?
继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问 题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种 情况下，我们应该尽量少用，甚至不用继承。  
## 组合相比继承有哪些优势?

继承主要有三个作用:表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通 过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂 的继承关系影响代码可维护性的问题。

### 如何判断该用组合还是继承?
1. 尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的 例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更 多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在 实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。  
2. 如果类之间的继承结构稳定(不会轻易改变)，继承层次比较浅(比如，最多有两层继承关 系)，继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很 深，继承关系复杂，我们就尽量使用组合来替代继承。  




